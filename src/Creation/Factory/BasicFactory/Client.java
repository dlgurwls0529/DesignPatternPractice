package Creation.Factory.BasicFactory;

public class Client {
    public static void main(String[] args) {
        System.out.println("test");
        // 상속을 통해 하나의 상위 타입이 있고, 그것에 의존하는 다양한 클래스가 있다고 하자
        // 예를 들어 배를 만드는 것을 상상해보자
        // 처음에 하얀배를 만들고 나서, 그것이 잘 되면
        // 검은 배나, 빨간 배 등 다양한 것들을 만들어야 하게 된다.
        // 보통 조건(색깔)을 받아서 if 문을 통해 각각을 리턴한다.
        /*
        if(color.equals("white"))
            return WhiteShip();
        else if(color.equals("Red"))
            return RedShip();
        */
        // 하지만, 이는 조건이 추가(노란 배)되면 복잡한 if else 를
        // 수정해야 한다. 이는 객체 지향 원칙 OCP 에 위배된다.
        // 이를 충족시키고 유연한 구조로 개선한 것이 팩토리 메소드 패턴이다.

        // 팩토리 메소드 패턴이란, 객체를 생성할 때 구체적으로
        // 어떤 것을 만들지 정하는 것을 서브클래스에 위임하는 것이다.
        // Creation.Factory 인터페이스로 객체를 리턴하는 추상 메소드를 선언하고
        // ConcreteFactory(서브클래스) 에서 그것을 구현한다.

        // 이를 통해서 새로운 요구사항이 발생하였을 때, 기존 클래스
        // 를 수정하는 것이 아니라 새로운 클래스(+팩토리)를
        // 추가하는 것만으로 처리가 가능해진다.
        // 하지만, 이 과정에서 각 Product 생성 과정을
        // 위임하기 위해 많은 수의 서브클래스가 만들어진다는 단점이 있다.

        // OCP(Open Closed Principal) 란 객체지향 5대 원칙 중 하나로,
        // 어떤 코드 수정 작업을 할 때, 클래스 단위에서,
        // 기존의 코드를 변경하는 것을 지양하고, 확장되는 방향으로
        // 이루어져야 한다는 것이다.
        // OCP 를 만족하는 디자인은 클래스 간의 결합도를 낮출 수 있다. (loosely coupled)
        // 왜냐하면, 수정 작업에서 기존 클래스를 안 건드리기 때문에
        // 수정에 의한 연쇄 오류가 발생하지 않기 때문이다.

        // DIP 도 지킬 수 있다는데, 난 잘 모르겠다.

        // 이것을 구현하는 방법은 버전마다 다르다.
        // 그것은 자바 8 에서 추가된 인터페이스 default 메소드와
        // 자바 9 에서 추가된 인터페이스 private 메소드의 추가로 인해 달라진다.
        // 두 메소드의 공통점은 모두 인터페이스에 구현체를 만들 수 있다는 점이고
        // 차이점은 하위 클래스에서 호출이 가능(default), 호출이 불가능(private)가 있다.

        // 8 버전에서는 private 메소드가 없으니
        // 인터페이스 - 추상클래스(private 메소드 구현) - 구상클래스로 구현한다.

        // 7 버전 이하에서는 default 메소드도 없어서
        // 인터페이스(전부 추상메서드) - 추상클래스(default, private 전부 구현) - 구상클래스로 구현한다.

        // 9 이상에서는 그냥 추상클래스 역할을 인터페이스가 대신한다.

        Turtle easternHermanTurtle = new EasternHermanTurtleFactory().createTurtle();
        easternHermanTurtle.introduce();

        Turtle aldabraTurtle = new AldabraTurtleFactory().createTurtle();
        aldabraTurtle.introduce();

        // Dependency injection
        // 위 예제에서는 내부 클래스(Client)에서
        // Turtle 과 Creation.Factory 의 의존 관계를 결정했다.
        // (Creation.Factory 가 변함에 따라 Turtle 이 영향받음,
        // 즉, Turtle 이 Creation.Factory 에 의존한다.)
        // (동헤르만인지 알다브라인지)
        // 반면 아래 예제는 외부 클래스(외부는 아니지만 외부라고 하자)
        // 에다가 함수 인자를 통해 의존 관계를 주입한다.
        // 이처럼 외부에서 해당 클래스의 의존 관계를 결정하도록 하는 것을
        // 의존성 (외부) 주입 (DI)라고 한다.
        // 자세한건 모르겠다.
        // https://tecoble.techcourse.co.kr/post/2021-04-27-dependency-injection/

        // https://stackoverflow.com/questions/929021/what-are-static-factory-methods
        // 정적 팩토리 메서드 : 단순히 클래스의 인스턴스를 반환하는 정적 메서드이다.
        // 이 메서드는 특정 클래스에 속해서 조건 분기를 통해 다양한 클래스를 반환한다.
        // Effective 자바에서 나오는 것이 이거다.

        // 팩토리 메소드 : 객체 생성을 위한 인터페이스를 정의하고, 그것을 구현하는 클래스가
        // 인스턴스화할 클래스를 결정한다. 즉, 객체 생성을 서브클래스에 위임하는 것이다.
        // GOF 의 디자인 패턴에 나오는 것이 이거다.

        // https://nanoson.tistory.com/46?category=687239
        // 정적 팩토리의 장점은 다섯 가지 정도가 있다.
        // 첫째, 이름을 가질 수 있다.
        // 인자로 이름을 전달함으로써, 반환 객체의 타입을 예상할 수 있다.
        // 둘째, 호출할 때마다 인스턴스를 매번 만들지 않아도 된다.
        // 조건 분기에 따라서 기존 객체를 재활용하고 싶으면, 그래도 된다.
        // ! 셋째, 다형성을 응용할 수 있다.
        // 메서드 반환 타입을 super class, 실제 반환 값을 sub class
        // 로 하면 다형성의 장점(구체적인 반환타입 몰르는 상태로 그냥 쓰면 된다.)
        // 을 누릴 수 있다?
        // ! 넷째, 입력 매개변수에 따라 다른 객체를 반환할 수 있다.
        //
        // 단점도 있다.
        // 첫째, 생성자를 묶어야 해서 정적 팩토리 메소드가 있는 클래스
        // 는 서브클래스를 못만든다.
        // 둘째, 다른 정적 메소드와 잘 구분이 안된다.
        // 그래서 네이밍 컨벤션을 적용하기는 한다.
        // 셋째, OCP 를 충족하지 않으므로, 유지 보수가 어렵다.
        //
        // 보다 유연하게 factory 의 목적을 달성
        // (새로운 제품군이 만들어지면, 이를 반영할 수 있다.)
        // 하는 것이 GOF 의 팩토리 메소드 패턴(팩토리 인터페이스?)

        // https://life-with-coding.tistory.com/485
        // 다형성이란 상속 관계에 놓인 클래스에서,
        // 상위 타입 참조 변수가 하위의 여러 타입으로 존재할 수 있다는 원리이다.
        // 엄밀히 말하면, 컴파일 타임에는 상위 타입이었던 상위 타입 참조 변수가
        // 런타임에는 하위 타입으로 변화하게 된다.
        // (sup = new Sub1() : sup 는 Sub1 타입)
        // (sup = new Sub2() : sup 는 Sub2 타입)
        // (sup = new Sub3() : sup 는 Sub3 타입)
        // (이처럼 실행에 따라 동적으로 타입이 변화!)
        // 이에 따라서, 상위 클래스가 동일한 방식으로 하위 클래스를 다르게 동작시킬 수 있다.
        // (호출은 컴파일 타임이고, 동작은 런타임이니까!!)
        // a, b extends c 일때
        // a.func()
        // b.func()
        // 두 개가 다른 동작이나, 호출 방식이 동일하다.

        // 이러한 다형성의 장점으로는 세 가지 정도가 있다.
        // 첫째, 유지보수가 쉽다.
        // 여러 객체를 하나의 타입으로 관리하기에 코드 관리가 편하고, 유지 보수가 용이하다.
        // (동일한 호출 방식으로 여러 객체가 동작하기 때문)
        // 둘째, 재사용성 증가
        // 다형성을 통해 객체를 재사용하기 쉬워진다고 한다.
        // void func(Sup sup) {
        //   sup.f1();
        //   sup.f2();
        // }
        // 위 func 함수에다가 인자로 sub1, sub2 등 하위 타입 객체로
        // 넣어주기만 하면, 각각 하위 타입에 맞는 동작을, 하나의 메소드인 func 로만
        // 동작할 수 있기 떄문인 듯 하다.
        // 셋째, 느슨한 결합
        // 위의 예시에서 만약 Sup 가 추상 타입이 아니라, 구체적인 타입(Sub1)이었다고 해보자 (노 다형성)
        // 그러면 타입 변화 시, 새로운 메소드를 정의하거나, 기존 메소드를 수정해야 할 것이다.
        // 즉, 해당 func 함수의 클래스가 Sub1에 의존한게 된다. (Sub1 의 변화에 따라 좌지우지되니까?)
        // 반면 다형성을 응용해 추상 타입 Sup 로 바꾸면, 타입 변화에도 코드 수정이 필요없다.
        // 즉, 의존성이 줄어드는 것이다.

        // 다형성의 구현 방법은
        // 첫째, 슈퍼 클래스와 서브 클래스
        // 둘째, 메소드 오버라이딩
        // 셋째, 상위 타입 객체에 하위 타입 객체 대입 (업캐스팅)

        // 이후 상위 타입 형식으로 자식 메소드 호출하여 활용한다.

        // https://secretroute.tistory.com/entry/140819
        // 다형성이 가능한 이유는 동적 바인딩 때문이다.
        // 이는 메소드가 실행 시점에 동작이 결정되는 것인데,
        // 덕분에 컴파일 시점에 슈퍼클래스 객체는 자신의 요소만 접근할 수 있으나
        // 런타임에는 서브클래스 객체에도 접근이 가능하다.

        // 바인딩이란 프로그램 구성 요소의 성격을 결정하는 것이다.
        // 예시로는 변수의 타입을 정하는 것이 있다.
        //  정적 바인딩은 컴파일 타임에 성격을 결정하는 것이고
        // 예시로는 C에서 컴파일 타임에 변수 타입을 정하는 것이 있다.
        // 이는 실행 효율이 높다.(컴파일 과정 중 최적화에 포함되기도 하고, 오버헤드가 없음)
        //  동적 바인딩은 런타임에 성격을 결정하는 것이다.
        // 예시로는 java 에서 다형성의 구현이 있다.
        // 런타임에 성격이 바뀌므로 유연한 구조를 만들 수 있다.

        // 함수 바인딩 :
        // 함수를 컴파일했을 때, 그 코드가 메모리에 저장되고
        // 저장된 주소가 호출하는 부분에 저장된다.
        // 이처럼 함수 코드의 메모리 주소로 호출부분을 연결하는 것을 바인딩이라 한다.

        // 정적 바인딩 (일반 함수):
        // 컴파일 시간에 호출되며, 점프할 주소가 그 시간에 결정되어 바인딩한다.
        // 동적 바인딩 (가상 함수):
        // 컴파일 타임에 바인딩하지 않고, 보류한다.
        // 바인딩하기 위한 공간 4바이트를 가지고 있다 런타임에 결정.
        // 단점 : 타입 체킹과 메모리 낭비
        // (기존에는 바로 함수 로직 주소가 있다면,
        // 동적 바인딩에는 바인딩 공간 주소가 있고, 그곳에 실행할 함수 주소가 들어가는 듯?)

        // https://kotlinworld.com/64
        // 의존성 주입

        ExternClass.introduceDI(new EasternHermanTurtleFactory());
        ExternClass.introduceDI(new AldabraTurtleFactory());

    }

}
